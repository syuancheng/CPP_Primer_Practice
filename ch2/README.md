# Chapter2 变量和基本类型

## 2.变量
变量都有数据类型，数据类型决定了：变量所占**内存空间大小**和**布局方式**、存储**值的范围**、**变量能参与的运算**。

### 变量定义
- 类型说明符 + 一个或多个变量名组成的列表。`int sum=0,value,units_sold=0;`
- 初始化：创建变量时赋予一个初始值。**赋值**是把对象的当前值擦除，而以一个新值来代替。
- 列表初始化 [define 2.2.2](../ch2/def2_2_1.cpp)
- 默认初始化
  - 如果没有指定初值，变量被默认初始化，默认值是由类型决定
  - 例外：定义在函数体(块)内部的内置类型将不被初始化
  - 建议初始化每一个内置类型的变量
- **初始化VS赋值**
  - **初始化**是创建变量时赋予其一个初始值
  - **赋值**是把对象的当前值擦除，而以一个新的值来替代。


### 变量声明和定义
- `extern int i`
- 变量能且只能被定义一次，但是可以被多次声明。


### 标识符
- 命名规范

### 名字的作用域
- 第一次使用变量时再定义它。
- 嵌套的作用域
  - 同时存在全局和局部变量时，已定义局部变量的作用域中可用::reused显式访问全局变量reused。
  - 但是用到全局变量时，尽量不适用重名的局部变量。

### 左值和右值
- 左值（l-value）可以出现在赋值语句的左边或者右边，比如变量；
- 右值（r-value）只能出现在赋值语句的右边，比如常量。


## 3.复合类型

### 引用
- 定义方式： 将声明符写成`&d`的形式来定义引用类型。
  - `int ival = 1024; int &refVal = ival;` 引用必须初始化
- 定义引用时，程序把引用和初始值<u>绑定</u>在一起。
  - 初始化完成后，一直绑定在一起。
  - 无法令引用重新绑定到另一个对象。
  - 对引用的所有操作实际上都是在与之绑定的对象上进行的。
  - 赋值: 给引用赋值，实际上是赋值给与引用绑定的对象。
  - 引用并非对象， 没有实际地址。

### 指针
- 指针本身是一个对象， 允许赋值和拷贝
- 生命周期中可以指向几个不同的对象
- 定义时无需赋初值
- 在块内定义的指针如果没初始化，将拥有一个不确定的值
- void指针可以存放任意类型的对象地址
- 指针和引用的区别 [练习](../ch2/point_vs_reference.cpp)
  - 指针可以指向任何其他类型
  - 引用是对象的别名
  - 一个引用是另外一个已经存在对象的别名，一个指针本身就是一个对象
  - 一旦初始化，一个引用会和它的初始化对象绑定， 并且不能再重新绑定其他对象。指针可以被赋值和拷贝。
  - 在整个生命周期中，引用只能和它初始化对象绑定，指针可以指向多个不同的对象
  - 引用必须初始化。指针在定义时不需要初始化。
  - 不能定义指向引用的指针，因为引用不是对象，没有实际地址。
- `int* p1, p2;`p1是指向int的指针，p2是int
- 指向指针的引用：`int *&r = p;` r是一个对指针p的引用
  - 从右向左阅读。

## 4.const限定符

### constexpr和常量表达式
  - 常量表达式：常量表达式是在编译时就可以被完全计算出值的表达式。常量表达式可以用于定义常量或者在编译时确定大小或值的地方。
    - 值不会改变
    - 编译过程就能得到计算结果
  - constexpr变量
    - 编译器常量， const并未区分  编译器常量和运行期常量。
  - constexpr方法
    - 如果其传入的参数可以在编译时期计算出来，那么这个函数就会产生编译时期的值。如果传入的参数如果不能在编译时期计算出来，那么constexpr修饰的函数就和普通函数一样了。